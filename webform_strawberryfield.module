<?php
/**
 * @file
 * Contains strawberryfield.module.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\webform\WebformSubmissionForm;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\file\Entity\File;
use Drupal\format_strawberryfield\Tools\IiifHelper;
use Drupal\Core\StreamWrapper\StreamWrapperInterface;
use Drupal\Core\File\FileSystemInterface;

/**
 * Alters a webform to help with embbeding in a node crud context.
 *
 * Implements hook_form_alter()
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param $form_id
 */
function webform_strawberryfield_form_alter(&$form,FormStateInterface $form_state, $form_id) {

  //@TODO if wizard make elements of progress-marker direct links to that wizard page
  if (strpos($form_id, 'webform_') === FALSE || strpos($form_id, 'node_') === 0) {
    return;
  }

  /** @var \Drupal\webform\WebformSubmissionForm $submission_form */
  $submission_form = $form_state->getFormObject();
  $form['#attached']['library'][] = 'webform_strawberryfield/webform_strawberryfield.nodeactions.toggle';

  if (strpos($form_id, 'webform_submission') === 0
    && $submission_form instanceof WebformSubmissionForm) {

    // @TODO check if we should use instead \Drupal\webform\WebformSubmissionForm::isAjax
    // I'm not totally convinced since we could be "ajaxifying" a webform here
    // that was not set as such in it's saved settings.

    /** @var  \Drupal\webform\Entity\WebformSubmission $webform_submission */
    $webform_submission = $submission_form->getEntity();

    $isWidget = FALSE;
    // @see \Drupal\webform_strawberryfield\Controller @var $data_defaults
    if (array_key_exists('strawberry_field_widget_state_id', $webform_submission->getData())) {
      $isWidget = TRUE;
      // Since we are just using webform to act as a widget, we tell workspace module all is safe here.
      //@TODO this is giving issues. Workspace can not serialize Webformsubmission form
      // Probably related to some dependency injection that includes and open DB reference
      //$form_state->set('workspace_safe', true);
    }

    if (!$isWidget ) {
      return;
    }
    if (isset($form['actions']['reset'])) {
      $form['actions']['reset']['#submit'] = ['webform_strawberryfield_widget_reset'];
    }

    /* @TODO make this a valid switch
    // We should not make close object available if inline
    // add a close model button
    $query = \Drupal::request()->query->all();
    $is_ajax = (!empty($query['ajax_form'])) ? TRUE : FALSE;
    $webform_close_controller_url = Url::fromRoute(
    'webform_strawberryfield.close_modal_webform');
    if ($is_ajax) {
    $form['actions']['closemodal'] = [
    '#type' => 'link',
    '#title' => t('Close Window'),
    '#url' => $webform_close_controller_url,
    '#attributes' => [
    'class' => [
    'use-ajax',
    'button',
    ],
    ],
    '#weight' => 100,
    ];
    }*/

    if ($form_state->get('current_page') === 'webform_preview') {
      /** @var \Drupal\webform\WebformSubmissionForm $submission_form */
      $submission_form = $form_state->getFormObject();

      foreach ($form['elements'] as $key => &$element) {
        if (isset($element['#type']) && ($element['#type'] == 'webform_wizard_page')) {
          $form['actions']['edit_wizard_page_'.$key][] = [
            '#type' => 'submit',
            '#value' => 'edit '.$element['#title'],
            '#submit' => [
              'webform_strawberryfield_go_to_page',
            ],
            '#attributes' => [
              'class' => ['js-webform-novalidate'],
            ],
            '#ajax' => [
              'callback' => [$submission_form, 'submitAjaxForm'],
              'event' => 'click',
              'disable-refocus' => true,
              'effect' => 'fade',
              'speed' => 1000,
              'progress' => [
                'type' => 'throbber',
                'message' => '',
              ]
            ],
            '#page' => $key,
          ];
        }
      }
    }
  }
}

/**
 * Custom Jump-to-a-webform-page wizard callback.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function webform_strawberryfield_go_to_page(array &$form, FormStateInterface $form_state) {

  /** @var \Drupal\webform\WebformSubmissionForm $submission_form */
  $submission_form = $form_state->getFormObject();

  /* @TODO: Use this valuable page number for something.
  $trigger = $form_state->getTriggeringElement();
  $current_page = $form_state->get('current_page');
  $wizard_page_id = $trigger['#page'];
   */

  // Submit using Mr. Wizard of WebOz.
  $submission_form->gotoPage($form, $form_state);
}

/**
 * Custom Reset Webform callback.
 *
 * This callback only resets to initial values but never resets whole state.
 * Needed to avoid our Webform widget to disconnect from its temp storage.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function webform_strawberryfield_widget_reset(array &$form, FormStateInterface $form_state) {

  /** @var \Drupal\webform\WebformSubmissionForm $submission_form */
  $submission_form = $form_state->getFormObject();

  /** @var  \Drupal\webform\Entity\WebformSubmission $webform_submission */
  $webform_submission = $submission_form->getEntity();


  /** @var  \Drupal\webform\WebformInterface $webform */
  $webform = $webform_submission->getWebform();

  // @TODO investigate how to use \Drupal\webform\WebformSubmissionInterface::getOriginalData
  // Instead of copy, store, restore way i'm applying here.

  // Iterate over our own passed from field data
  $keeparound = array();
  foreach ($webform_submission->getData() as $keys => $data) {
    if (strpos($keys, 'strawberry_field') !== FALSE) {
      $keeparound[$keys] =  $data;
    }
  }
  // We should always have at least 3 keys
  // "strawberry_field_widget_state_id"
  // "strawberry_field_widget_source_entity_uuid"
  // "strawberry_field_stored_values"
  // @see \Drupal\webform_strawberryfield\Controller @var $data_defaults

  $restored_data = array();
  if (!empty($keeparound)) {
    // This brings stored data to the outside so webform can see it again
    $restored_data = $keeparound + $keeparound['strawberry_field_stored_values'];
  }

  // Call the original reset
  $submission_form->reset($form, $form_state);

  // Give submission our original values!
  $form_state->getFormObject()->getEntity()->setData($restored_data);
}

/**
 * Totally cosmetic hide/display main entity save button when in webform mode.
 *
 * Implements hook_FORM_ID_form_alter()
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param $form_id
 */
function webform_strawberryfield_form_node_form_alter(&$form, FormStateInterface &$form_state, $form_id) {
  //$node = $form_state->getFormObject()->getEntity();
  // Means this form has a webform widget

  if (isset($form_state->getStorage()['webform_machine_name'])){
    $input = $form_state->getUserInput();

    if ((!isset($input['_triggering_element_name'])) || (isset($input['_triggering_element_value']) && $input['_triggering_element_value']!='Save Metadata')) {
      foreach ($form['actions'] as $key => &$buttons) {
        if ($key == 'delete') {
          $buttons['#access'] = FALSE;
        }
      }
    }
  }
}

/**
 * Implements hook_theme().
 */
function webform_strawberryfield_theme() {
  $info = [
    'webform_metadata_nominatim' => [
      'render element' => 'element',
    ],
    'webform_metadata_panoramatour' => [
      'render element' => 'element',
    ],
    'webform_inline_fieldwidget_form' => [
      'variables' => [],
      'template' => 'webform_strawberryfield-inlinefieldwidget',
      'base hook' => 'webform'
    ],
  ];
  return $info;
}

/**
 * Prepares variables for location composite element templates.
 *
 * Default template: webform-metadata-nominatim.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: An associative array containing the properties of the element.
 */
function template_preprocess_webform_metadata_nominatim(array &$variables) {
  $variables['content'] = $variables['element'];

  unset($variables['content']['value']);
  unset($variables['content']['nominatim']);
  unset($variables['content']['feature']);
  $variables['fetchbox'] = $variables['element']['value'];
  $variables['fetchbox_button'] = $variables['element']['nominatim'];
  $variables['fetchbox_table'] = $variables['element']['feature'];
}

/**
 * Prepares variables for location composite element templates.
 *
 * Default template: webform-metadata-panoramatour.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: An associative array containing the properties of the element.
 */
function template_preprocess_webform_metadata_panoramatour(array &$variables) {
  $variables['content'] = $variables['element'];
}

/**
 * Implements hook_theme_suggestions_HOOK_alter() for webforms.
 *
 * @param $suggestions
 * @param array $variables
 */
function webform_strawberryfield_theme_suggestions_webform_alter(&$suggestions, array $variables) {
  // Add our own webform suggestion based on a given data attribute set by
  // \Drupal\webform_strawberryfield\Element\WebformWithOverride::preRenderWebformElement
  $element = $variables['element'];
  // This is in particular for 'webform_inline_fieldwidget' element
  if (isset($element['#attributes']['data-webform-inline-fieldwidget'])) {
    $suggestions = ['webform_inline_fieldwidget_form', 'webform_inline_fieldwidget_form__' . $element['#webform_id']];
  }
}

/**
 * Implements hook_preprocess_HOOK()
 *
 * @see template_preprocess_webform_element_image_file()
 *
 * @param array $variables
 *   An associative array containing the following key:
 *   - element: The webform element.
 *   - value: The content for the element.
 *   - options Associative array of options for element.
 *   - file: The element's File object.
 *   - style_name: An image style name.
 *   - format: Image formatting (link or modal)
 */
function webform_strawberryfield_preprocess_webform_element_image_file(array &$variables) {

  if (!empty($variables['file'])) {
    // TODO do we need a setting for this?
    $max_width = 320;

    //@TODO this is quite a copy of what Format_strawberry does. We should
    // Move all that logic to helper methods into \Drupal\format_strawberryfield\Tools\IiifHelper
    /** @var \Drupal\file\FileInterface $file */
    $file = $variables['file'];

    $variables['image']['#type'] = 'container';

    $style_name = $variables['style_name'];
    $format = $variables['format'];

    $uri = $file->getFileUri();
    $url = Url::fromUri(file_create_url($uri));
    if (!$file->isTemporary()) {

      $iiifserversettings = \Drupal::config(
        'format_strawberryfield.iiif_settings'
      );
      $iiifhelper = new IiifHelper(
        $iiifserversettings->get('pub_server_url'),
        $iiifserversettings->get('int_server_url')
      );
      // Deal with Drupal 8.8.x v/s 8.7
      if (method_exists(\Drupal::service('stream_wrapper_manager'),'getTarget')) {
        $iiifidentifier = urlencode(
          \Drupal::service('stream_wrapper_manager')->getTarget(
            $file->getFileUri()
          ));
      }
      else {
        $iiifidentifier = urlencode(file_uri_target($file->getFileUri()));
      }

      if ($iiifidentifier == NULL || empty($iiifidentifier)) {
        // Nothing to do, lets leave this untouched.
        return;

      }

      $iiifpublicinfojson = $iiifhelper->getPublicInfoJson($iiifidentifier);
      $iiifsizes = $iiifhelper->getImageSizes($iiifidentifier);

      if (!$iiifsizes) {
        $message = t(
          'We could not fetch Image sizes from IIIF @url',
          [
            '@url' => $iiifpublicinfojson,
          ]
        );
        \Drupal::logger('webform_strawberryfield')->warning($message);
        // Nothing to do, lets leave this untouched.
        return;
      }
      else {
        //@see \template_preprocess_image for further theme_image() attributes.
        // Look. This one uses the public accesible base URL. That is how world works.
        $iiifserverthumb = "{$iiifserversettings->get('pub_server_url')}/{$iiifidentifier}" . "/full/{$max_width},/0/default.jpg";
        $url = $iiifserverthumb;
      }
    }
    else {
      // Its a temporary file, just uploaded, IIIF can not see it yet

      $route_parameters = [
        'uuid' => $file->uuid(),
        'format' => 'default.'. pathinfo($file->getFilename(), PATHINFO_EXTENSION)
      ];
      $publicurl = Url::fromRoute('format_strawberryfield.tempiiifbinary', $route_parameters);
      $url = $publicurl->toString();
      // Extract EXIF and show it to the user!
      /** @var \Drupal\Core\File\FileSystem $file_system */
      $scheme =  \Drupal::service('file_system')->uriScheme($uri);
      $templocation = NULL;
      // If the file isn't stored locally make a temporary copy.
      if (!isset(\Drupal::service('stream_wrapper_manager')
          ->getWrappers(StreamWrapperInterface::LOCAL)[$scheme])) {
        // Local stream.
        $cache_key = md5($uri);
        $templocation = \Drupal::service('file_system')->copy($uri, 'temporary://sbr_' . $cache_key . '_' . basename($uri), FileSystemInterface::FILE_EXISTS_REPLACE);
      } else {
        $templocation = \Drupal::service('file_system')->realpath($file->getFileUri());
      }
      if ($templocation) {
        $result = exec('exiftool -json -q '.escapeshellcmd($templocation), $output, $status);
        if ($status != 0) {
          \Drupal::service('messenger')
            ->addMessage(t('Ups. We could not get EXIF from your file. Sorry.'));
        }
        else {
          $variables['image']['exif'] = [
            '#type' => 'markup',
            '#markup' => $output
          ];


        }
      }




    }

    $extension = pathinfo($uri, PATHINFO_EXTENSION);
    $is_image = in_array($extension, ['gif', 'png', 'jpg', 'jpeg', 'jp2', 'tiff']);

    // Build image.
    if ($is_image && \Drupal::moduleHandler()->moduleExists('image') && $style_name && ImageStyle::load($style_name)) {
      $variables['image']['singleimage'] = [
        '#theme' => 'image_style',
        '#style_name' => $variables['style_name'],
      ];
    }
    else {
      // Note: The 'image' template uses root-relative paths.
      // The 'image' is preprocessed to use absolute URLs.
      // @see webform_preprocess_image().
      $variables['image']['singleimage'] = [
          '#theme' => 'image'
      ];
    }
    // Change the class from webform-image-file to webform-strawberryfield-image-file
    // to avoid webform_preprocess_image() messing up our IIIF link
    // by appending the current global.
    // @TODO Style element here feels like a hack. We can do better
    $variables['image']['singleimage'] += [
      '#uri' => $url,
      '#attributes' => [
        'class' => ['webform-strawberryfield-image-file'],
        'alt' => $file->getFilename(),
        'title' => $file->getFilename(),
        'style' => "max-width:{$max_width}px;height:auto",
      ],
    ];

    // For the Results table always display the file name as a tooltip.
    if (strpos(\Drupal::routeMatch()->getRouteName(), 'webform.results_submissions') !== FALSE) {
      $variables['attached']['library'][] = 'webform/webform.tooltip';
      $variables['image']['singleimage']['#attributes']['class'][] = 'js-webform-tooltip-link';
    }

    // Wrap 'image' in a link/modal.
    if ($format && $format != 'image') {
      $variables['image']['singleimage'] = [
        '#type' => 'link',
        '#title' => $variables['image'],
        '#url' => $url,
      ];
      switch ($format) {
        case 'modal':
          $variables['image']['singleimage'] += [
            '#attributes' => ['class' => ['js-webform-image-file-modal', 'webform-image-file-modal']],
            '#attached' => ['library' => ['webform/webform.element.image_file.modal']],
          ];
          break;

        case 'link':
          $variables['image']['singleimage'] += ['#attributes' => ['class' => ['webform-image-file-link']]];
          break;
      }
    }

  }
}


