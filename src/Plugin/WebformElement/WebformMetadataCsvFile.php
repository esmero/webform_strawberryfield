<?php
/**
 * Created by PhpStorm.
 * User: dpino
 * Date: 12/2/18
 * Time: 5:17 PM
 */

namespace Drupal\webform_strawberryfield\Plugin\WebformElement;

use Drupal\Component\Utility\Bytes;
use Drupal\Core\EventSubscriber\MainContentViewSubscriber;
use Drupal\file\Entity\File;
use Drupal\webform\WebformInterface;
use Drupal\webform\WebformSubmissionForm;
use Drupal\webform\WebformSubmissionInterface;
use Drupal\webform\Plugin\WebformElement\WebformManagedFileBase;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;
use Drupal\file\FileInterface;
use Drupal\strawberryfield\Tools\JsonSimpleXMLElementDecorator;
use Drupal\strawberryfield\Tools\SimpleXMLtoArray;

/**
 * Provides a 'file element' that can import CSV into a flat JSON.
 *
 * @WebformElement(
 *   id = "webform_metadata_csv_file",
 *   api = "https://api.drupal.org/api/drupal/core!modules!file!src!Element!ManagedFile.php/class/ManagedFile",
 *   label = @Translation("Import Metadata in CSV format from a File"),
 *   description = @Translation("Provides a form element for uploading, saving a CSV file and parsing the content as metadata/webform submission data."),
 *   category = @Translation("File upload elements"),
 *   states_wrapper = TRUE,
 * )
 */
class WebformMetadataCsvFile extends WebformMetadataFile {

  /**
   * {@inheritdoc}
   */
  public function getDefaultProperties() {
    $properties = parent::getDefaultProperties() + [
        'utf8' => TRUE,
      ] + parent::getDefaultProperties();
    return $properties;
  }

  protected function getUploadLocation(array $element, WebformInterface $webform) {
    return parent::getUploadLocation($element,
      $webform); // TODO: Change the autogenerated stub
  }

  /**
   * {@inheritdoc}
   */
  protected function defineDefaultProperties() {
    $properties = parent::defineDefaultProperties() + [
        'utf8' => TRUE,
      ];
    return $properties;
  }


  /*
   * {@inheritdoc}
   */
  public function form(array $form, FormStateInterface $form_state) {
    $form = parent::form($form, $form_state);
    $form['file']['keepfile']['#title'] = $this->t("Keep imported CSV File after persisting?");
    $form['file']['utf8'] = [
      '#type' => 'checkbox',
      '#title' => $this->t('Validate CSV for UTF8.'),
      '#description' => $this->t(' If not we will automatically replace invalid characters for a "?"'),
      '#default_value' => TRUE,
    ];
    return $form;
  }

  public function prepare(array &$element, WebformSubmissionInterface $webform_submission = NULL) {
    parent::prepare($element,
      $webform_submission); // TODO: Change the autogenerated stub
    // Only validate if utf8 validation is enabled. If not we will clean up.
    if ($this->getElementProperty($element, 'utf8')) {
      $element['#element_validate'][] = [
        get_class($this),
        'validateManagedUTF8Csv',
      ];
    }
  }


  /**
   * Process CSV content.
   *
   * @param \Drupal\file\FileInterface $file
   *
   * @return array
   */
  protected function processFileContent(FileInterface $file) {
    $jsonarray = [];
    $data = [];
    if (!$file) {
      return $jsonarray;
    }
    $uri = $file->getFileUri();
    //read csv headers
    ini_set('auto_detect_line_endings', TRUE);
    setlocale(LC_CTYPE, 'en_US.UTF-8');

    $index = 0;
    $headers = [];
    //@TODO. Can we require a list of headers? Check against a list?

    if (($handle = fopen($uri, "r")) !== FALSE) {
      while (($csvdata = fgetcsv($handle, "2048", ",")) !== FALSE) {
        $index++;
        if ($index < 2) {
          foreach ($csvdata as $values) {
            // Because for each is always faster than map
            // In case the cleaning up means we end with empty, we still add it
            // Because we need to maintain the column index to fetch the right
            // row/cell data.
            $headers[] = trim(preg_replace('/[^[:print:]]/', '', $values));
          }
          if (!count($headers)) {
            break 1;
          }
        }
        else {
          // Actual data
          $row_value = $this->safe_json_encode($csvdata);
          $row_value = $row_value ? json_decode($row_value, TRUE, 512,
            JSON_INVALID_UTF8_SUBSTITUTE) : [];
          foreach ($headers as $columnindex => $header) {
            // Totally skip empty headers(includes empty ones after cleanup)
            if (strlen($header) > 0) {
              $data[$index][$header] = $row_value[$columnindex] ?? "";
            }
          }
        }
      }
    }
    else {
      return $jsonarray;
    }

    if (!empty($data) && ($index >= 2)) {
      $md5 = md5_file($uri);
      $jsonarray = [
        'dr:uuid' => $file->uuid(),
        'checksum' => $md5,
        'crypHashFunc' => 'md5',
        'webform_element_type' => $this->pluginDefinition['id'],
        'standard' => NULL,
        'content' => $data,
        'format' => 'csv',
      ];
    }
    return $jsonarray;
  }

  /**
   * Form API callback. Validate CSV for UTF8 correctness
   *
   * @see \Drupal\webform\WebformSubmissionForm::validateForm
   */
  public static function validateManagedUTF8Csv(array &$element, FormStateInterface $form_state, &$complete_form) {
    // Set empty files to NULL and exit.
    if (empty($element['#files'])) {
      return;
    }

    $fids = array_keys($element['#files']);

    // Get WebformSubmissionForm object.
    $form_object = $form_state->getFormObject();
    if (!($form_object instanceof WebformSubmissionForm)) {
      return;
    }

    // Skip validation when removing file upload.
    $trigger_element = $form_state->getTriggeringElement();
    $op = (string) $trigger_element['#value'];
    if (in_array($op, [(string) t('Remove'), (string) t('Remove selected')])) {
      return;
    }

    // Track file size across all file upload elements.
    static $total_file_size = 0;
    /** @var \Drupal\file\FileInterface[] $files */
    $files = File::loadMultiple($fids);
    foreach ($files as $file) {

      $uri = $file->getFileUri();
      //read csv headers
      ini_set('auto_detect_line_endings', TRUE);
      setlocale(LC_CTYPE, 'en_US.UTF-8');

      $index = 0;
      $headers = [];
      //@TODO. Can we require a list of headers? Check against a list?
      if (($handle = fopen($uri, "r")) !== FALSE) {
        while (($csvdata = fgetcsv($handle, "2048", ",")) !== FALSE) {
          $index++;
          if ($index < 2) {
            foreach ($csvdata as $values) {
              // Because for each is always faster than map
              // In case the cleaning up means we end with empty, we still add it
              // Because we need to maintain the column index to fetch the right
              // row/cell data.
              $headers[] = trim(preg_replace('/[^[:print:]]/', '', $values));
            }
            if (!count($headers)) {
              $message = t("Uploaded CSV contains no valid header/column names. Please Fix (export as UTF-8) and replace the file.");
              $form_state->setError($element, $message);
              break;
            }
          }
          else {
            // Actual data
            $encoded = json_encode($csvdata);
            if ($encoded === FALSE && $csvdata && json_last_error() == JSON_ERROR_UTF8) {
              $message = t("Uploaded CSV contains Invalid UTF-8 characters, first error found at row %row. Please Fix (export as UTF-8) and replace the file.",
                [
                  '%row' => $index,
                ]);
              $form_state->setError($element, $message);
              break;
            }
          }
        }
      }
    }
  }

}
